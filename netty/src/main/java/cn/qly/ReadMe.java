package cn.qly;

public class ReadMe {


    /**
     * 框架代码导读
     * ------------------------------------------------------------------------------------
     * 1.为什么出现EventLoop？
     * 根据selector的代码逻辑，循环执行
     * while (selector.select() > 0) {
     *     ...
     * }
     * 所以叫做事件循环
     *
     *
     *
     * ------------------------------------------------------------------------------------
     */


    /**
     * 面试题总结
     * ------------------------------------------------------------------------------------
     * 1.Netty用到了哪些design pattern和idiom？
     * ------------------------------------------------------------------------------------
     * 答：
     *
     * ------------------------------------------------------------------------------------
     * 2.ServerBootstrap指定NIOServerSocketChannel之后，需要设置TCP参数，backlog是什么意思？
     * ------------------------------------------------------------------------------------
     * 答：backlog指定了内核为此socket排队的最大连接数，对于给定的监听端口，内核要维护两个队列：未链接队列和已连接队列。服务器处于listen
     * 状态时，收到客户端syn时在未完成队列中创建一个新的entry，当客户端ack到达之后，该entry会从未完成连接队列搬到已完成连接队列尾部。当
     * 进程调用accept时，从已完成队列中的头部取出一个entry给进程，当已完成队列为空时进程将睡眠，知道有entry在已完成连接队列中才唤醒。
     * backlog被规定为两个对立总和的最大值。
     *
     * ------------------------------------------------------------------------------------
     * 3.有哪些Java I/O模型？它们的应用场景？
     * ------------------------------------------------------------------------------------
     * 答：BIO、NIO、AIO
     *      1)BIO同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器端就需要启动一个
     *  线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。适用于连接数目较小且固定的架构，
     *  这种方式对服务器资源要求比较高。
     *      2)NIO同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到
     *  多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。适用于连接数目多且连接比较短的架构，比如
     *  聊天服务器，弹幕系统，服务器间通讯等。
     *      3)AIO异步非阻塞，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程
     *  它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接较长的应用，比如
     *  相册服务器，充分调用OS参与并发操作。
     *
     * ------------------------------------------------------------------------------------
     * 4.常见的线程模型有哪些？各有什么优缺点？
     * ------------------------------------------------------------------------------------
     * 答：传统阻塞I/O服务模式、Reactor模式，Netty线程模式其中Reactor分：单Reactor单线程、单Reactor多线
     * 程、主从Reactor多线程。
     *      1)阻塞I/O服务模式，当并发数很大，会创建大量的线程，占用很大系统资源；连接创建后，如果当前线程暂时
     *  没有数据可读，该线程会阻塞在read操作，造成线程资源浪费。
     *  注：针对传统阻塞I/O服务模型的2个缺点，解决方案：基于I/O复用模型，多个连接共用一个阻塞对象；基于线程池
     *  共用线程资源。
     *      2)单Reactor单线程，模型简单，没有多线程；只有一个线程，无法发挥多核CPU性能，Handler处理某个业务
     *  时，整个进程无法处理其他连接事件，很容易导致性能瓶颈；可靠性不行。适用于客户端的数量有限，业务处理非常快速
     *  比如Redis在业务处理的时间复杂度O(1)的情况。
     *      3)单Reactor多线程，可以充分的利用多核cpu的处理能力；多线程数据共享和访问比较复杂，Reactor处理所有
     *  事件的监听和响应，并在单线程中运行，在高并发场景容易出现性能瓶颈。
     *  注：handler只负责响应时间，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程
     *  处理业务
     *      4)主从Reactor多线程，父线程与子线程职责明确，父线程只需要接受新连接，子线程完成后续的业务处理；父线程
     *  与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无序返回数据。应用广泛:包括Nginx主从
     *  Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型
     *
     *  ------------------------------------------------------------------------------------
     *  5.任务队列中的Task 3种典型使用场景
     *  ------------------------------------------------------------------------------------
     *  答： 1)用户程序自定义的普通任务
     *      2)用户自定义定时任务
     *      3)非当前Reactor线程调用Channel的各种方法
     *  线程池中每一个线程资源对应一个socket连接，在该socket连接中的，若有任务需要时间较长，可放到taskQueue中
     *  等待点前线程资源空闲，再去执行，若该socket的线程中，有死循环，则taskQueue中的任务永远得不到执行
     *  应该先看懂线程池o(╥﹏╥)o
     *
     *  ------------------------------------------------------------------------------------
     *  6.谈谈NIO与零拷贝
     *  ------------------------------------------------------------------------------------
     *  答：  零拷贝从操作系统角度看，如果kernel buffer中数据没有重复的，就是零拷贝
     *      1)传统I/O：4次拷贝：2次DMA，2次CPU
     *           先从硬盘通过DMA拷贝到kernel buffer，然后一次CPU拷贝，将kernel buffer的数据通过CPU拷贝
     * 到用户缓冲区，然后一次CPU拷贝，将用户缓冲区的数据拷贝到socket buffer，最后，将socket buffer的数据DMA到网卡
     *      2)mmap:3次拷贝：2次DMA，1次CPU
     *           先从硬盘通过DMA拷贝到kernel buffer，然后一次CPU拷贝，将kernel buffer的数据通过CPU拷贝
     *  到socket buffer，最后，直接将socket buffer的数据DMA到网卡
     *      3)sendFile:2次拷贝：2次DMA，1次CPU(数据量很小)
     *          先从硬盘通过DMA拷贝到kernel buffer，然后一次CPU拷贝，将该缓冲区的指针，大小等信息拷贝到socket buffer
     *  最后，直接将kernel buffer的数据DMA到网卡
     *
     *  ------------------------------------------------------------------------------------
     *  7.谈谈Netty中的异步模型
     *  ------------------------------------------------------------------------------------
     *  答：  1)当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知
     *  和回调来通知调用者。
     *       2)Netty中的I/O操作是异步的，包括bind、write、connect等操作会简单的返回一个ChannelFuture。
     *       3)调用者并不能立刻获得结果，而是通过Future-listener机制，用户可以方便的主动获取或者通过通知机制
     *  获得I/O操作结果
     *       4)Netty的异步模型是建立在Future和Callback之上的。Future的核心思想：假设一个方法fun，计算过程
     *  可能非常耗时，等待fun返回显然不合适。那么可以在调用fun的时候，立马返回一个Future，后续可以通过Future
     *  取监控方法fun的处理过程。
     *
     *  ------------------------------------------------------------------------------------
     *  8.协议如http、WebSocket与编解码与TCP粘包/拆包的联系与区别？
     *  ------------------------------------------------------------------------------------
     *
     *  ------------------------------------------------------------------------------------
     *  9.Linux网络I/O模型
     *  1)阻塞I/O模型
     *  默认情况下，所有文件操作都是阻塞的。以socket为例：在进程空间中调用recvfrom，其系统调用直到数据包到达且
     *  被复制到应用进程的缓冲区或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段
     *  时间内都是被阻塞的。
     *  2)非阻塞I/O模型
     *  recvfrom从应用层到内核时，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O
     *  模型进行轮询检查这个状态，看内核是不是有数据到来。
     *  3)I/O复用模型：Linux提供select/poll,进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select
     *  操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持
     *  的fd数量有限，因此它的使用收到了一些制约。Linux还提供一个epoll系统调用,epoll使用基于事件驱动方式代替顺序
     *  扫描，因此性能更高。
     *  4)信号驱动I/O模型
     *  首先开启socket信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数(此系统调用立刻返回，进程继续工作
     *  它是非阻塞的)。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，
     *  并通知主循环函数处理数据。
     *  5)异步I/O
     *  告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区)通知我们。这种模型与信号驱动
     *  模型的主要区别是：信号驱动I/O由内核通知我们何时可以开始一个I/O操作：异步I/O模型由内核通知我们I/O操作何时已经完成。
     *
     *
     *  ------------------------------------------------------------------------------------
     *  9.Netty中的Channel和jdk nio包下的Channel是什么关系？
     *  10.Netty客户端Bootstrap.connect(...)的过程，详细的说一下？
     *  11.Channel注册到NioEventLoop的过程，详细的说下？
     *  12.NioEventLoop是什么呢？它的工作流程是怎样的呢？
     *  13.Pipeline设计模式非常灵活，说一下对它的理解？
     *  14.Netty使用Pipeline模式时做了一些优化，就是向后传递Handler时的优化，你知道做了什么优化吗？
     *  15.谈谈你对NioEventLoopGroup的理解？
     *  16.NioEventLoop内部的任务队列做过优化，你知道是什么优化吗？
     *  ------------------------------------------------------------------------------------
     */


}
